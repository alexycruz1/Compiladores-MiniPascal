package Analizador;
import java_cup.runtime.*;
import org.json.simple.*;
import com.google.gson.*;
import java.util.ArrayList;
import Arbol.*;
import Table.*;
import Types.*;

parser code {:

	public ArrayList<String> errors = new ArrayList(); 
	public int offset = 0;
	public ArrayList current_scope = new ArrayList();

	public String Intermediate_code = "";
	public SymbolTable sym_table = new SymbolTable();
	public String current_type = "";
	public String current_operator = "";

	public Node myTree = new Node("INIT");

	public JSONObject program_json = new JSONObject();

	public String printTree(JSONObject obj){
		Gson gson = new GsonBuilder().setPrettyPrinting().create();
		JsonParser jp = new JsonParser();
		JsonElement je = jp.parse(obj.toString());
		String prettyJsonString = gson.toJson(je);
		return prettyJsonString;
	}

	public void backScope() {
		if(current_scope.size() > 0) {
			current_scope.remove(current_scope.size()-1);
		}
	}

	public void report_error(String message, Object info) {
		if (info instanceof Symbol) {
			if (((Symbol)info).left != -1 && ((Symbol)info).right != -1) {
				int line = (((Symbol)info).left)+1;
				int column = (((Symbol)info).right)+1;
				errors.add(message + " " + " (" + (line + 1) + ", " + (column + 1) + ").");
			}
		}
		errors.add(message);
	}
	public void syntax_error(Symbol s){
		String val = s.value != null ? s.value.toString() : getTokenName(s.sym);
		//errors.add("Error sintactico en la linea: " + s.left +" columna: "+ s.right + " simbolo: " + val);
		errors.add("Error sintactico en la linea: " + (s.left + 1) + " columna: " + (s.right + 1) + " simbolo: " + val);
	}

	public void unrecovered_syntax_error(Symbol s) {
		if (s.left < 1 ||s.left < 1) return;
		String val = s.value != null ? s.value.toString() : getTokenName(s.sym);
		//errors.add("Error sintactico en la linea: " + s.left +" columna: "+ s.right + " simbolo: " + val);
		errors.add("Error sintactico en la linea: " + (s.left + 1) +" columna: "+ (s.right + 1) + " simbolo: " + val);

	}

	public String getTokenName(int id){
		String value = sym.terminalNames[id];
		switch(id) {
			case sym.ParentesisAbierto:
				return "(";
			case sym.ParentesisCerrado:
				return ")";
			case sym.Coma:
				return ",";
			case sym.AsignacionTipo:
				return ":";
			case sym.AsignacionVariable:
				return ":=";
			case sym.FinalInstruccion:
				return ";";
			case sym.For:
				return "for";
			case sym.While:
				return "while";
			case sym.Repeat:
				return "repeat";
			case sym.If:
				return "if";
			case sym.AsignacionIgual:
				return "=";	
			default:
				return value;  
		}
	}
:};

terminal Begin, End, For, Function, If, To, Do, Else, Then, Until, While, Write, Read, 
		Tipo, Not, Or, And, OpRel, OpSuma, OpMult, AsignacionVariable, AsignacionTipo, 
		AsignacionIgual, FinalInstruccion, ParentesisAbierto, ParentesisCerrado, Coma, Punto, 
		Variable, Constchar, Conststr, Program, Repeat, Procedure, Numero, Var,
		Record;

non terminal program, identifier_list, declarations, subprogram_declaration, compound_statement, type,
		standard_type, subprogram_declarations, subprogram_head, arguments, parameter_list, optional_statements,
		statement_list, statement, expression, procedure_statement, expression_list, factor, mult_expression, 
		constant, constant_character, constant_string, simple_expression, write_function, read_function,
		relation, extra_expression, final_instruccion_error, records, lista_record_values, char_declaration, 
		integer_declaration, boolean_declaration;
		
// program //
program ::=
	Program: p Variable: v
		{:
			current_scope.add(v);
		:}
	final_instruccion_error declarations: d subprogram_declarations: sd compound_statement: cs Punto: punto
		{:
			if(errors.size() == 0) {
				System.out.println("COMPILADO CON EXITO");				
			} else {				
				System.out.println("\t\t--- COMPILACIÓN FALLIDA ---");
			}					

			JSONObject myJson = new JSONObject();
			myJson.put("Program", p.toString());
			myJson.put("Variable", v.toString());
			myJson.put("declarations", (JSONObject) d);
			myJson.put("subprogram_declarations", (JSONObject) sd);
			myJson.put("compound_statement", (JSONObject) cs);
			myJson.put("Punto", punto.toString());

			program_json = myJson;
			
			RESULT = myJson;
		:}
		|
	Program: p
		{:
			current_scope.add("ROOT");
		:}
	final_instruccion_error declarations: d subprogram_declarations: sd compound_statement: cs Punto: punto
		{:
			if(errors.size() == 0) {
				System.out.println("COMPILADO CON EXITO");				
			} else {
				System.out.println("\t\t--- COMPILACIÓN FALLIDA ---");
			}

			JSONObject myJson = new JSONObject();
			myJson.put("Program", p.toString());
			myJson.put("declarations", (JSONObject) d);
			myJson.put("subprogram_declarations", (JSONObject) sd);
			myJson.put("compound_statement", (JSONObject) cs);
			myJson.put("Punto", punto.toString());

			program_json = myJson;
			RESULT = myJson;
		:}
	;
// \ program //

// identifier_list //
identifier_list ::=
	Variable: v
		{:
			ArrayList ids = new ArrayList();
			Token token = new Token(v.toString(), vright + 1, vleft + 1);
			ids.add(token);
			RESULT = ids;
		:}
		|
	identifier_list: idl Coma Variable: v
		{:
			ArrayList ids = (ArrayList) idl;
			Token token = new Token(v.toString(), vright + 1, vleft + 1);
			ids.add(token);
			RESULT = ids;
		:}
;
// \ identifier_list //

// declarations //
declarations ::=
	declarations: d Var: var identifier_list: idl AsignacionTipo: at type: t FinalInstruccion: fi
		{:
			
			ArrayList ids = ((ArrayList) idl);
			for(int i = 0; i < ids.size(); i++) {
				Token token = (Token)ids.get(i);
				CustomType type = new CustomType(tright + 1, tleft + 1, t.toString().toUpperCase());
				Scope scope = new Scope(current_scope.clone());
				SymbolRow sr = new SymbolRow(token, type, scope, offset);
				offset++;
				sym_table.addSymbol(sr);
			}

			JSONObject myJson = new JSONObject();
			myJson.put("declarations", (JSONObject) d);
			myJson.put("Var", var.toString());
			JSONArray id_list = new JSONArray();
			for(Object value : (ArrayList) idl) {
				id_list.add(((Token)value).valex);		
			}				
			myJson.put("identifier_list", id_list);
			myJson.put("AsignacionTipo", at.toString());
			myJson.put("type", t.toString());
			myJson.put("FinalInstruccion", fi.toString());
			RESULT = myJson;
		:}
		|
	char_declaration: d
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("char_declaration", (JSONObject) d);
			RESULT = myJson;
		:}
		|
	integer_declaration: d
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("integer_declaration", (JSONObject) d);
			RESULT = myJson;
		:}
		|
	boolean_declaration: d
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("boolean_declaration", (JSONObject) d);
			RESULT = myJson;
		:}
		|
	declarations Var identifier_list error type FinalInstruccion 
		{:
			 parser.report_error("Error en la asignacion de tipo", null); 
		:}
		|
	declarations: d records: r
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("declarations", (JSONObject) d);
			myJson.put("records", (JSONObject) r);
			RESULT = myJson;
		:}
		|			
		{:
			// Empty
		:}
	; 
// \ declarations //

// char_declaration //
char_declaration ::=
	declarations:d Var: var identifier_list: idl AsignacionTipo: at type: t AsignacionIgual: ai constant_character: cc FinalInstruccion: fi
		{:
			ArrayList ids = ((ArrayList) idl);
			for(int i = 0; i < ids.size(); i++) {
				Token token = (Token)ids.get(i);
				CustomType type = new CustomType(tright + 1, tleft + 1, t.toString().toUpperCase());
				Scope scope = new Scope(current_scope.clone());
				SymbolRow sr = new SymbolRow(token, type, scope, offset);
				offset++;
				sym_table.addSymbol(sr);
			}

			JSONObject myJson = new JSONObject();
			myJson.put("declarations", (JSONObject) d);
			myJson.put("Var", var.toString());
			JSONArray id_list = new JSONArray();
			for(Object value : (ArrayList) idl) {
				id_list.add(((Token)value).valex);		
			}				
			myJson.put("identifier_list", id_list);
			myJson.put("AsignacionTipo", at.toString());
			myJson.put("type", t.toString());
			myJson.put("AsignacionIgual", ai.toString());
			myJson.put("constant_character", cc.toString());
			myJson.put("FinalInstruccion", fi.toString());
			RESULT = myJson;
		:}
	;
// \ char_declaration //

// integer_declaration //
integer_declaration ::=
	declarations: d Var: var identifier_list: idl AsignacionTipo: at type: t AsignacionIgual: ai Numero: n FinalInstruccion:fi
		{:
			ArrayList ids = ((ArrayList) idl);
			for(int i = 0; i < ids.size(); i++) {
				Token token = (Token)ids.get(i);
				CustomType type = new CustomType(tright + 1, tleft + 1, t.toString().toUpperCase());
				Scope scope = new Scope(current_scope.clone());
				SymbolRow sr = new SymbolRow(token, type, scope, offset);
				offset++;
				sym_table.addSymbol(sr);
			}

			JSONObject myJson = new JSONObject();
			myJson.put("declarations", (JSONObject) d);
			myJson.put("Var", var.toString());
			JSONArray id_list = new JSONArray();
			for(Object value : (ArrayList) idl) {
				id_list.add(((Token)value).valex);		
			}				
			myJson.put("identifier_list", id_list);
			myJson.put("AsignacionTipo", at.toString());
			myJson.put("type", t.toString());
			myJson.put("AsignacionIgual", ai.toString());
			myJson.put("Numero", n.toString());
			myJson.put("FinalInstruccion", fi.toString());
			RESULT = myJson;
		:}
	;
// \ integer_declaration //

// boolean_declaration //
boolean_declaration ::=
	declarations: d Var: var identifier_list: idl AsignacionTipo: at type: t AsignacionIgual: ai Variable: v FinalInstruccion: fi
		{:
			ArrayList ids = ((ArrayList) idl);
			for(int i = 0; i < ids.size(); i++) {
				Token token = (Token)ids.get(i);
				CustomType type = new CustomType(tright + 1, tleft + 1, t.toString().toUpperCase());
				Scope scope = new Scope(current_scope.clone());
				SymbolRow sr = new SymbolRow(token, type, scope, offset);
				offset++;
				sym_table.addSymbol(sr);
			}

			JSONObject myJson = new JSONObject();
			myJson.put("declarations", (JSONObject) d);
			myJson.put("Var", var.toString());
			JSONArray id_list = new JSONArray();
			for(Object value : (ArrayList) idl) {
				id_list.add(((Token)value).valex);		
			}				
			myJson.put("identifier_list", id_list);
			myJson.put("AsignacionTipo", at.toString());
			myJson.put("type", t.toString());
			myJson.put("AsignacionIgual", ai.toString());
			myJson.put("Variable", v.toString());
			myJson.put("FinalInstruccion", fi.toString());
			RESULT = myJson;
			
		:}
	;
// \ boolean_declaration //

// type //
type ::=
	standard_type: t
		{:
			RESULT = t;
		:}
		|
		{:
			// Empty
		:}
	;
// \ type //

// standard_type //
standard_type ::=
	Tipo: t
		{:
			RESULT = t;
		:}
	;
// \ standard_type //

// subprogram_declarations //
subprogram_declarations ::=
	subprogram_declarations: sds subprogram_declaration: sd final_instruccion_error
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("subprogram_declaration", (JSONObject) sd);		
			myJson.put("subprogram_declarations", (JSONObject) sds);
			RESULT = myJson;
		:}
		|
		subprogram_declarations:sds final_instruccion_error
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("subprogram_declarations", (JSONObject) sds);		
			RESULT = myJson;
		:}
		|
		{:			
			// Empty
		:}
	; 
// \ subprogram_declarations //

// subprogram_declaration //
subprogram_declaration ::=
	subprogram_head: sh declarations: d compound_statement: cs
		{:
			backScope();

			JSONObject myJson = new JSONObject();
			myJson.put("subprogram_head", (JSONObject) sh);
			myJson.put("declarations", (JSONObject) d);			
			myJson.put("compound_statement", (JSONObject) cs);
			RESULT = myJson;
		:}
	;
// \ subprogram_declaration //

// subprogram_head //
subprogram_head ::=
	Function: p Variable: v arguments: a AsignacionTipo: at standard_type: t final_instruccion_error
		{:						
			JSONObject myJson = new JSONObject();
			myJson.put("Function", p.toString());
			myJson.put("Variable", v.toString());
			myJson.put("arguments", (JSONObject) a);
			myJson.put("AsignacionTipo", at.toString());
			myJson.put("standard_type", t.toString());

			String type_a = ((JSONObject) a).get("validate_type").toString() + " => " + t.toString().toUpperCase();

			myJson.put("validate_type", type_a);

			Token token = new Token(v, vright + 1, vleft + 1);
			CustomType type = new CustomType(pright + 1, pleft + 1, type_a);
			Scope scope = new Scope(current_scope.clone());
			SymbolRow sr = new SymbolRow(token, type, scope, offset);
			offset++;
			sym_table.addSymbol(sr);

			current_scope.add(v);

			RESULT = myJson;
		:}
		|
	Function: p Variable: v arguments: a AsignacionTipo: at final_instruccion_error
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("Function", p.toString());
			myJson.put("Variable", v.toString());
			myJson.put("arguments", (JSONObject) a);
			myJson.put("AsignacionTipo", at.toString());

			String type_a = ((JSONObject) a).get("validate_type").toString() + " => VOID";

			myJson.put("validate_type", type_a);
			
			Token token = new Token(v, vright + 1, vleft + 1);
			CustomType type = new CustomType(pright + 1, pleft + 1, type_a);
			Scope scope = new Scope(current_scope.clone());
			SymbolRow sr = new SymbolRow(token, type, scope, offset);
			offset++;
			sym_table.addSymbol(sr);

			current_scope.add(v);

			RESULT = myJson;
		:}
		|
	Procedure: p Variable: v arguments: a FinalInstruccion: fi
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("Procedure", p.toString());
			myJson.put("Variable", v.toString());
			myJson.put("arguments", (JSONObject) a);
			myJson.put("FinalInstruccion", fi.toString());

			String type_a = ((JSONObject) a).get("validate_type").toString() + " => VOID";

			myJson.put("validate_type", type_a);
			Token token = new Token(v, vright + 1, vleft + 1);
			CustomType type = new CustomType(pright + 1, pleft + 1, type_a);
			Scope scope = new Scope(current_scope.clone());
			SymbolRow sr = new SymbolRow(token, type, scope, offset);
			offset++;
			sym_table.addSymbol(sr);

			current_scope.add(v);

			RESULT = myJson;
		:}
	;
// \ subprogram_head //

// arguments //
arguments ::=
	ParentesisAbierto: pa parameter_list: pl ParentesisCerrado: pc
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("ParentesisAbierto", pa.toString());
			myJson.put("parameter_list", (JSONObject) pl);
			myJson.put("ParentesisCerrado", pc.toString());

			String type_list = ((JSONObject) pl).get("validate_type").toString();

			myJson.put("validate_type", "(" + type_list.substring(0, type_list.length() - 3) + ")");

			RESULT = myJson;
		:}
		|
		{:
			JSONObject myJson = new JSONObject();
			
			myJson.put("validate_type", "VOID");

			RESULT = myJson;
		:}
	;
// \ arguments //

// parameter_list //
parameter_list ::=
	identifier_list: il AsignacionTipo: at type: t 
		{:
			JSONObject myJson = new JSONObject();
			JSONArray id_list = new JSONArray();
			for(Object value : (ArrayList) il) {
				id_list.add(((Token)value).valex);		
			}				
			myJson.put("identifier_list", id_list);
			myJson.put("AsignacionTipo", at.toString());
			myJson.put("type", t.toString());

			//
			String real_type = "";
			for(Object value : (ArrayList) il) {
				real_type = t.toString() + " X " + real_type;
			}

			myJson.put("validate_type", real_type);

			RESULT = myJson;
		:}
		|
	parameter_list: pl FinalInstruccion: fi identifier_list: il AsignacionTipo: at type: t
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("parameter_list", (JSONObject) pl);
			myJson.put("FinalInstruccion", fi.toString());
			JSONArray id_list = new JSONArray();
			for(Object value : (ArrayList) il) {
				id_list.add(((Token)value).valex);		
			}
			myJson.put("identifier_list", id_list);
			myJson.put("AsignacionTipo", at.toString());
			myJson.put("type", t.toString());

			//
			String real_type = "";
			for(Object value : (ArrayList) il) {
				real_type = t.toString() + "X" + real_type;
			}
			String type_list = ((JSONObject) pl).get("validate_type").toString();
			real_type = type_list + real_type;

			myJson.put("validate_type", real_type);

			RESULT = myJson;
		:}
	;
// \ parameter_list //

// compound_statement //
compound_statement ::=
	Begin: b optional_statements: os End: e
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("Begin", b.toString());
			myJson.put("optional_statements", (JSONObject) os);
			myJson.put("End", e.toString());
			RESULT = myJson;
		:}
	;
// \ compound_statement //

// optional_statements //
optional_statements ::=
	statement_list: state_list
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("statement_list", (JSONObject) state_list);
			RESULT = myJson;
		:}
		|
		{:
			// Empty
		:}
	;
// \ optional_statements //

// statement_list //
statement_list ::=
	statement: state FinalInstruccion: fi
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("statement", (JSONObject) state);
			myJson.put("FinalInstruccion", fi.toString());
			RESULT = myJson;
		:}
		|
	error FinalInstruccion
		{:
			parser.report_error("Error en el statement", null);
		:}
		|
	statement_list: state_list statement: state FinalInstruccion: fi
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("statement_list", (JSONObject) state_list);
			myJson.put("statement", (JSONObject) state);
			myJson.put("FinalInstruccion", fi.toString());
			RESULT = myJson;
		:}
		|
	statement_list error FinalInstruccion
		{:
			parser.report_error("Error en el statement", null);
		:}
	;
// \ statement_list //

// statement //
statement ::=
	Variable: v AsignacionVariable: av expression: exp
		{:
			JSONObject myJson = new JSONObject();
			SymbolRow current_var = sym_table.find(v.toString(), current_scope);
			if(current_var == null) {
				errors.add("Error: No existe la variable " + v.toString() + " (" + (vleft + 1) + ", " + (vright +1) +")." );
			} else if(current_var.type.type.equals("PROCEDURE") || current_var.type.type.equals("PROCEDURE")) {
				errors.add("Error: El identificador " + v.toString() + " es un subprograma, no es posible asignar un valor (" + (vleft + 1) + ", " + (vright +1) +")." );				
			}

			myJson.put("Variable", v.toString());
			myJson.put("AsignacionVariable", av.toString());
			myJson.put("expression", (JSONObject) exp);
			RESULT = myJson;
		:}
		|
	procedure_statement: ps
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("procedure_statement", (JSONObject) ps);
			RESULT = myJson;
		:}
		|
	compound_statement: cs
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("compound_statement", (JSONObject) cs);
			RESULT = myJson;
		:}
		|
	write_function: w
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("write_function", (JSONObject) w);
			RESULT = myJson;
		:}
		|
	read_function: r
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("read_function", (JSONObject) r);
			RESULT = myJson;
		:}
		|
	If: i expression: exp Then: t statement: if_state Else: els statement: if_else_state
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("If", i.toString());
			myJson.put("expression", (JSONObject) exp);
			myJson.put("Then", t.toString());
			myJson.put("statement", (JSONObject) if_state);
			myJson.put("Else", els.toString());
			myJson.put("statement", (JSONObject) if_else_state);
			RESULT = myJson;
		:}
		|
	If error
		{:
			parser.report_error("Error en el If", null);
		:}
		|
	While: w expression: exp Do: d statement: state
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("While", w.toString());
			myJson.put("expression", (JSONObject) exp);
			myJson.put("Do", d.toString());
			myJson.put("statement", (JSONObject) state);
			RESULT = myJson;			
		:}
		|
	While error
		{:
			parser.report_error("Error en el While", null);
		:}
		|
	For: f Variable: v AsignacionVariable: av factor: fac To: to expression: exp Do: d statement: state
		{:
			SymbolRow current_var = sym_table.find(v.toString(), current_scope);
			if(current_var == null) {
				errors.add("Error: No existe la variable " + v.toString() + " (" + (vleft + 1) + ", " + (vright +1) +")." );
			} else if(current_var.type.type.equals("PROCEDURE") || current_var.type.type.equals("PROCEDURE")) {
				errors.add("Error: El identificador " + v.toString() + " es un subprograma, no es posible asignar un valor (" + (vleft + 1) + ", " + (vright +1) +")." );				
			}
			JSONObject myJson = new JSONObject();
			myJson.put("For", f.toString());
			myJson.put("Variable", v.toString());
			myJson.put("AsignacionVariable", av.toString());
			myJson.put("factor", (JSONObject) fac);
			myJson.put("To", to.toString());
			myJson.put("expression", (JSONObject) exp);
			myJson.put("Do", d.toString());
			myJson.put("statement", (JSONObject) state);
			RESULT = myJson;
		:}
		|
	For error
		{:
			parser.report_error("Error en el For", null);
		:}
		|
	Repeat:r statement: state Until: u Variable: v AsignacionIgual: ai expression: exp
		{:
			SymbolRow current_var = sym_table.find(v.toString(), current_scope);
			if(current_var == null) {
				errors.add("Error: No existe la variable " + v.toString() + " (" + (vleft + 1) + ", " + (vright +1) +")." );
			} else if(current_var.type.type.equals("PROCEDURE") || current_var.type.type.equals("PROCEDURE")) {
				errors.add("Error: El identificador " + v.toString() + " es un subprograma, no es posible asignar un valor (" + (vleft + 1) + ", " + (vright +1) +")." );				
			}
			JSONObject myJson = new JSONObject();
			myJson.put("Repeat", r.toString());
			myJson.put("statement", (JSONObject) state);
			myJson.put("Until", u.toString());
			myJson.put("Variable", v.toString());
			myJson.put("AsignacionIgual", ai.toString());
			myJson.put("expression", (JSONObject) exp);
			RESULT = myJson;
		:}
		|
	Repeat error
		{:
			parser.report_error("Error en el Repeat", null);
		:}
	;
// \ statement //

// write_function //
write_function ::=
	Write: w ParentesisAbierto: pa constant_string: cs Coma: coma Variable: v ParentesisCerrado: pc
		{:
			SymbolRow current_var = sym_table.find(v.toString(), current_scope);
			if(current_var == null) {
				errors.add("Error: No existe la variable " + v.toString() + " (" + (vleft + 1) + ", " + (vright +1) +")." );
			}
			JSONObject myJson = new JSONObject();
			myJson.put("Write", w.toString());
			myJson.put("ParentesisAbierto", pa.toString());
			myJson.put("constant_string", cs.toString());
			myJson.put("Coma", coma.toString());
			myJson.put("Variable", v.toString());
			myJson.put("ParentesisCerrado", pc.toString());
			RESULT = myJson;
		:}
		|
	Write: w ParentesisAbierto: pa constant_string: cs ParentesisCerrado: pc
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("Write", w.toString());
			myJson.put("ParentesisAbierto", pa.toString());
			myJson.put("constant_string", cs.toString());
			myJson.put("ParentesisCerrado", pc.toString());
			RESULT = myJson;
		:}
	;
// \ write_function //

// read_function //
read_function ::=
	Read: r ParentesisAbierto: pa Variable: v ParentesisCerrado: pc
		{:
			SymbolRow current_var = sym_table.find(v.toString(), current_scope);
			if(current_var == null) {
				errors.add("Error: No existe la variable " + v.toString() + " (" + (vleft + 1) + ", " + (vright +1) +")." );
			} else if(current_var.type.type.equals("PROCEDURE") || current_var.type.type.equals("PROCEDURE")) {
				errors.add("Error: El identificador " + v.toString() + " es un subprograma, no es posible asignar un valor (" + (vleft + 1) + ", " + (vright +1) +")." );				
			}
			JSONObject myJson = new JSONObject();
			myJson.put("Read", r.toString());
			myJson.put("ParentesisAbierto", pa.toString());
			myJson.put("Variable",  v.toString());
			myJson.put("ParentesisCerrado", pc.toString());
			RESULT = myJson;
		:}
	;
// \ read_function //

// procedure_statement //
procedure_statement ::=
	Variable: v
		{:
			SymbolRow current_var = sym_table.find(v.toString(), current_scope);
			if(current_var == null) {
				errors.add("Error: No existe la variable " + v.toString() + " (" + (vleft + 1) + ", " + (vright +1) +")." );
			} else if(!current_var.type.type.contains(" => ")) {
				errors.add("Error: El identificador " + v.toString() + " no es un subprograma (" + (vleft + 1) + ", " + (vright +1) +")." );				
			}
			JSONObject myJson = new JSONObject();
			myJson.put("Variable", v.toString());
			RESULT = myJson;
		:}
		|
	Variable: v ParentesisAbierto: pa expression_list: el ParentesisCerrado: pc
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("Variable", v.toString());
			myJson.put("ParentesisAbierto", pa.toString());
			myJson.put("expression_list", (JSONObject) el);
			myJson.put("ParentesisCerrado", pc.toString());

			SymbolRow current_var = sym_table.find(v.toString(), current_scope);
			if(current_var == null) {
				errors.add("Error: No existe la variable " + v.toString() + " (" + (vleft + 1) + ", " + (vright +1) +")." );
				myJson.put("validate_type", "ERROR");
			} else if(!current_var.type.type.contains(" => ")) {
				errors.add("Error: El identificador " + v.toString() + " no es un subprograma (" + (vleft + 1) + ", " + (vright +1) +")." );
				myJson.put("validate_type", current_var.type.type);
			} else {

				// VALIDAR TIPO PARAMETROS

				String type1 = current_var.type.type;
				type1 = type1.substring(0, type1.lastIndexOf(" =>"));

				String type2 = ((JSONObject) el).get("validate_type").toString().replaceAll("ERROR", "VOID");
				type2 = "(" + type2 + ")";

				if(type1.equals(type2)) {
					type1 = current_var.type.type;
				} else {
					errors.add("Error: No se encuentra subprograma " + v.toString() + " con parámetros " + type2 + " (" + (vleft + 1) + ", " + (vright +1) +")." );
				}				
				myJson.put("validate_type", type1.substring(type1.lastIndexOf(" =>") + 4, type1.length()) );
			}
			
			RESULT = myJson;
		:}
	;
// \ procedure_statement //

// expression_list //
expression_list ::=
	expression: exp extra_expression: ex_exp
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("expression", (JSONObject) exp);
			myJson.put("extra_expression", (JSONObject) ex_exp);

			// VALIDAR TIPO PARAMETROS

			String type1 = ((JSONObject) exp).get("validate_type").toString();
			String type2 = ((JSONObject) ex_exp).get("validate_type").toString();

			String real_type = "";

			if(type2.equals("NULL")) {
				real_type = type1;
			} else {
				real_type = type1 + " X " + type2;
			}

			myJson.put("validate_type", real_type);

			RESULT = myJson;
		:}
	;
// \ expression_list //

// expression //
expression ::=
	expression: exp And: and relation: rel
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("expression", (JSONObject) exp);
			myJson.put("And", and.toString());
			myJson.put("relation", (JSONObject) rel);
			
			// VALIDAR TIPO COMPARACION

			String type1 = ((JSONObject) exp).get("validate_type").toString();
			String type2 = ((JSONObject) rel).get("validate_type").toString();

			if(type1.equals("ERROR") && type2.equals("ERROR")) {
				myJson.put("validate_type", "ERROR");
			}
			
			else if(type1.equals(type2) && type1.equals("BOOLEAN")) {
				myJson.put("validate_type", "BOOLEAN");
			}

			else {
				errors.add("Error: No se puede operar " + type1 + " " + and.toString() + " " + type2 + " (" + (expleft + 1) + ", " + (expright +1) +")." );
				myJson.put("validate_type", "ERROR");
			}
			// _________________________________________

			RESULT = myJson;
		:}
		|
	expression: exp Or: or relation: rel
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("expression", (JSONObject) exp);
			myJson.put("Or", or.toString());
			myJson.put("relation", (JSONObject) rel);
			
			// VALIDAR TIPO COMPARACION

			String type1 = ((JSONObject) exp).get("validate_type").toString();
			String type2 = ((JSONObject) rel).get("validate_type").toString();

			if(type1.equals("ERROR") && type2.equals("ERROR")) {
				myJson.put("validate_type", "ERROR");
			}
			
			else if(type1.equals(type2) && type1.equals("BOOLEAN")) {
				myJson.put("validate_type", "BOOLEAN");
			}

			else {
				errors.add("Error: No se puede operar " + type1 + " " + or.toString() + " " + type2 + " (" + (expleft + 1) + ", " + (expright +1) +")." );
				myJson.put("validate_type", "ERROR");
			}
			// _________________________________________

			RESULT = myJson;
		:}
		|
	relation: rel
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("relation", (JSONObject) rel);
			myJson.put("validate_type", ((JSONObject) rel).get("validate_type").toString());
			RESULT = myJson;
		:}
		|
	error
		{:
			parser.report_error("Error en la expresion", null);
			JSONObject myJson = new JSONObject();
			myJson.put("validate_type", "ERROR");
			RESULT = myJson;
		:}
	;
// \ expression //

// extra_expression //
extra_expression ::=
	Coma: coma expression: exp extra_expression: ex_exp
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("Coma", coma.toString());
			myJson.put("expression", (JSONObject) exp);
			myJson.put("extra_expression", (JSONObject) ex_exp);

			// VALIDAR TIPO PARAMETROS

			String type1 = ((JSONObject) exp).get("validate_type").toString();
			String type2 = ((JSONObject) ex_exp).get("validate_type").toString();

			String real_type = "";

			if(type2.equals("NULL")) {
				real_type = type1;
			} else {
				real_type = type1 + " X " + type2;
			}

			myJson.put("validate_type", real_type);

			RESULT = myJson;
		:}
		|
		{:
			// Empty
			JSONObject myJson = new JSONObject();
			myJson.put("validate_type", "NULL");
			RESULT = myJson;
		:}
	;
// \ extra_expression //

// relation //
relation ::=
	simple_expression: simp_exp
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("simple_expression", (JSONObject) simp_exp);
			myJson.put("validate_type", ((JSONObject) simp_exp).get("validate_type").toString());
			RESULT = myJson;
		:}
		|
	simple_expression: simp_exp OpRel: oprel simple_expression: simp_exp2
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("simple_expression", (JSONObject) simp_exp);
			myJson.put("OpRel", oprel.toString());
			myJson.put("simple_expression", (JSONObject) simp_exp2);

			// VALIDAR TIPO COMPARACION

			String type1 = ((JSONObject) simp_exp).get("validate_type").toString();
			String type2 = ((JSONObject) simp_exp2).get("validate_type").toString();

			if(type1.equals("ERROR") && type2.equals("ERROR")) {
				myJson.put("validate_type", "ERROR");
			}
			
			else if(type1.equals(type2)) {
				myJson.put("validate_type", "BOOLEAN");
			}

			else {
				errors.add("Error: No se puede operar " + type1 + " " + oprel.toString() + " " + type2 + " (" + (simp_expleft + 1) + ", " + (simp_expright +1) +")." );
				myJson.put("validate_type", "ERROR");
			}
			// _________________________________________

			RESULT = myJson;
		:}
		|
	simple_expression: simp_exp AsignacionIgual: asignacion_igual simple_expression: simp_exp2
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("simple_expression", (JSONObject) simp_exp);
			myJson.put("AsignacionIgual", asignacion_igual.toString());
			myJson.put("simple_expression", (JSONObject) simp_exp2);
			
			// VALIDAR TIPO COMPARACION

			String type1 = ((JSONObject) simp_exp).get("validate_type").toString();
			String type2 = ((JSONObject) simp_exp2).get("validate_type").toString();

			if(type1.equals("ERROR") && type2.equals("ERROR")) {
				myJson.put("validate_type", "ERROR");
			}
			
			else if(type1.equals(type2)) {
				myJson.put("validate_type", "BOOLEAN");
			}

			else {
				errors.add("Error: No se puede operar " + type1 + " " + asignacion_igual.toString() + " " + type2 + " (" + (simp_expleft + 1) + ", " + (simp_expright +1) +")." );
				myJson.put("validate_type", "ERROR");
			}
			// _________________________________________
			
			RESULT = myJson;
		:}
	;
// \ relation //

// simple_expression //
simple_expression ::=
	simple_expression: simp_exp OpSuma: opsuma mult_expression: mult_exp
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("simple_expression", (JSONObject) simp_exp);
			myJson.put("OpSuma", opsuma.toString());
			myJson.put("mult_expression", (JSONObject) mult_exp);

			// VALIDAR TIPO SUMA
			// SOLO VALIDO PARA INTEGER Y STRING

			String type1 = ((JSONObject) simp_exp).get("validate_type").toString();
			String type2 = ((JSONObject) mult_exp).get("validate_type").toString();

			if(type1.equals("ERROR") && type2.equals("ERROR")) {
				myJson.put("validate_type", "ERROR");
			}
			
			else if(type1.equals(type2) && type1.equals("INTEGER")) {
				myJson.put("validate_type", "INTEGER");
			}

			else if(type1.equals(type2) && type1.equals("STRING")) {
				myJson.put("validate_type", "STRING");
			}

			else if(type1.equals("STRING") || type2.equals("STRING")) {
				errors.add("Error: No se puede operar " + type1 + " " + opsuma.toString() + " " + type2 + ", optando por STRING (" + (simp_expleft + 1) + ", " + (simp_expright +1) +"). " );
				myJson.put("validate_type", "STRING");
			}

			else if(type1.equals("INTEGER") || type2.equals("INTEGER")) {
				errors.add("Error: No se puede operar " + type1 + " " + opsuma.toString() + " " + type2 + ", optando por INTEGER (" + (simp_expleft + 1) + ", " + (simp_expright +1) +"). " );
				myJson.put("validate_type", "INTEGER");
			}

			else {
				errors.add("Error: No se puede operar " + type1 + " " + opsuma.toString() + " " + type2 + " (" + (simp_expleft + 1) + ", " + (simp_expright +1) +")." );
				myJson.put("validate_type", "ERROR");
			}
			// _________________________________________

			RESULT = myJson;
		:}
		|
	mult_expression: mult_exp
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("mult_expression", (JSONObject) mult_exp);
			myJson.put("validate_type", ((JSONObject) mult_exp).get("validate_type").toString());
			RESULT = myJson;
		:}
	;
// \ simple_expression //

// mult_expression //
mult_expression ::=
	mult_expression: mult_exp OpMult: opmult factor: fac
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("mult_expression", (JSONObject) mult_exp);
			myJson.put("OpMult", opmult.toString());
			myJson.put("factor", (JSONObject) fac);
			
			// VALIDAR TIPO MULTIPLICACION
			// SOLO VALIDO PARA INTEGER

			String type1 = ((JSONObject) mult_exp).get("validate_type").toString();
			String type2 = ((JSONObject) fac).get("validate_type").toString();

			if(type1.equals(type2) && type1.equals("INTEGER")) {
				myJson.put("validate_type", "INTEGER");
			}

			else if(type1.equals("ERROR") && type2.equals("ERROR")) {
				myJson.put("validate_type", "ERROR");
			}

			else if(type1.equals("INTEGER") || type2.equals("INTEGER")) {
				errors.add("Error: No se puede operar " + type1 + " " + opmult.toString() + " " + type2 + ", optando por INTEGER (" + (mult_expleft + 1) + ", " + (mult_expright +1) +"). " );
				myJson.put("validate_type", "INTEGER");
			}

			else {
				errors.add("Error: No se puede operar " + type1 + " " + opmult.toString() + " " + type2 + " (" + (mult_expleft + 1) + ", " + (mult_expright +1) +")." );
				myJson.put("validate_type", "ERROR");
			}
			
			// _________________________________________
						
			RESULT = myJson;
		:}
		|
	factor: fac
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("validate_type", ((JSONObject) fac).get("validate_type").toString());
			myJson.put("factor", (JSONObject) fac);
			RESULT = myJson;
		:}
	;
// \ mult_expression //

// factor //
factor ::=
	Numero: numero
		{:
			JSONObject myJson = new JSONObject();
			current_type = "INTEGER";
			myJson.put("type", "INTEGER");
			myJson.put("validate_type", "INTEGER");
			myJson.put("value", new Integer(numero.toString()));
			
			RESULT = myJson;
		:}
		|
	Variable: v
		{:
			JSONObject myJson = new JSONObject();
			SymbolRow current_var = sym_table.find(v.toString(), current_scope);
			if(current_var == null) {
				errors.add("Error: No existe la variable " + v.toString() + " (" + (vleft + 1) + ", " + (vright + 1) + ")." );
				myJson.put("validate_type", "ERROR");
				myJson.put("type", "UNKNOWN");
				myJson.put("error", new Boolean(true));
			} else {
				current_type = current_var.type.type;
				myJson.put("type", "INTEGER"); 
				myJson.put("validate_type", "INTEGER"); 
				JSONArray path = new JSONArray();
				for(Object value : current_var.scope.path) {
					path.add(value.toString());		
				}
				myJson.put("scope", path );
			}
			myJson.put("id", v.toString());

			RESULT = myJson;
		:}
		|
	Not: not factor: fac
		{:		
			JSONObject myJson = new JSONObject();
			
			if(!current_type.equals("BOOLEAN")) {
				errors.add("Error: Intenta negar una expresión de tipo no BOOLEAN (" + (facleft + 1) + ", " + (facright +1) +")." );
				myJson.put("error", new Boolean(true));
				myJson.put("validate_type", "ERROR");
			}
			myJson.put("type", current_type);
			myJson.put("validate_type", current_type);

			RESULT = myJson;
		:}
		|
	constant: cons
		{:
			JSONObject myJson = new JSONObject();

			current_type = ((JSONObject) cons).get("validate_type").toString();

			myJson.put("type", ((JSONObject) cons).get("validate_type").toString());
			myJson.put("validate_type", ((JSONObject) cons).get("validate_type").toString());

			RESULT = myJson;
		:}
		|
	ParentesisAbierto: pa expression_list: exp_list ParentesisCerrado: pc
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("ParentesisAbierto", pa.toString());
			myJson.put("expression_list", (JSONObject) exp_list);
			myJson.put("ParentesisCerrado", pc.toString());
			myJson.put("validate_type", ((JSONObject) exp_list).get("validate_type").toString());
			RESULT = myJson;
		:}
	;
// \ factor //

// constant //
constant ::=
	constant_character: cc
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("value", cc.toString());
			myJson.put("validate_type", "CHAR");
			RESULT = myJson;
		:}
		|
	constant_string: cs
		{:
			JSONObject myJson = new JSONObject();
			myJson.put("value", cs.toString());
			myJson.put("validate_type", "STRING");
			RESULT = myJson;
		:}
	;
// \ constant //

// constant_character //
constant_character ::=
	Constchar: c
		{:
			RESULT = c;
		:}
	;
// \ constant_character //

// constant_string //
constant_string ::=
	Conststr: c
		{:
			RESULT = c;
		:}
	;
// \ constant_string //

// final_instruccion_error //
final_instruccion_error ::=
	FinalInstruccion
		{:

		:}
		|
	error
		{:
			parser.report_error("Falta final de instruccion", null);
		:}
    ;
// \ final_instruccion_error //

// records //
records ::=
	Var:var Variable: v AsignacionIgual:ai Record:rec lista_record_values: lvr End:e
		{:
			ArrayList<Record_Attribute> attributes = (ArrayList<Record_Attribute> ) lvr;
			Token token = new Token(v, vright + 1, vleft + 1);
			RecordType type = new RecordType(token, attributes, vright + 1, vleft + 1);
			Scope scope = new Scope(current_scope.clone());
			SymbolRow sr = new SymbolRow(token, type, scope, offset);
			offset++;
			sym_table.addSymbol(sr);

			JSONObject myJson = new JSONObject();
			myJson.put("Var", var.toString());
			myJson.put("Variable", v.toString());
			myJson.put("AsignacionIgual", ai.toString());
			myJson.put("Record", rec.toString());
			JSONArray values = new JSONArray();
			for(Record_Attribute value : (ArrayList<Record_Attribute>) lvr) {
				values.add(value.toString());		
			}
			myJson.put("lista_record_values", values);
			myJson.put("End", e.toString());
			RESULT = myJson;
		 :}
	;
// \ records //

// lista_record_values //
lista_record_values ::=
	Variable: v AsignacionTipo Tipo: t FinalInstruccion lista_record_values: lrv
		{:
			ArrayList<Record_Attribute> attributes;
			if(lrv instanceof ArrayList) {
				attributes = (ArrayList<Record_Attribute> ) lrv;
			} else {
				attributes = new ArrayList<Record_Attribute>();
			}
			Token token = new Token(v, vright + 1, vleft + 1);
			CustomType  type = new CustomType(vright + 1, vleft + 1, t.toString().toUpperCase());
			Record_Attribute attribute = new Record_Attribute(token, type);
			attributes.add(attribute);
			RESULT = attributes;
		:}
		|
		{:
			// Empty
		:}
	;
// \ lista_record_values //
